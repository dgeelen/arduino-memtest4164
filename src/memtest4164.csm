.nolist                  // We don't want to actually include defs in our listing file.
.include "m328pdef.inc"  // defines all the pins on the ATMega328 so we can
                         // use them by their names rather than addresses (not fun).
.list                    // We DO want to include the following code in our listing ;D


#include "interrupts.csm"

ISR_SET_HANDLER(ISR_RESET,      main                               )
ISR_SET_HANDLER(ISR_USART_RX,   serial_interrupt_handler_rx        )
ISR_SET_HANDLER(ISR_USART_UDRE, serial_interrupt_handler_data_empty)
ISR_SET_HANDLER(ISR_TIMER0_COMPA, m4164_interrupt_handler_dram_refresh)
ISR_SET_ORG_FOR_USER_CODE()

#include <boost/preprocessor/seq/for_each.hpp>
#include "utility_macros.csm"
#include "utility_functions.csm"
#include "serial.csm"
#include "m4164.csm"
#include "libc.csm"

main:
	; set up the stack
	ldi    r25, low(RAMEND)
	out    SPL, r25
	ldi    r25, high(RAMEND)
	out    SPH, r25

	initialise_registers()

	serial_init(115200)

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;  4164 DRAM setup                                                         ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Configure timer0 to refresh the DRAM every 15.625us
	;
	; clear Force Compare, WGM02, select 1/256 prescaler
	ldi    r25, (0<<FOC0A)|(0<<FOC0B)|(0<<WGM02)|(1<<CS02)|(0<<CS01)|(0<<CS00)
	out    TCCR0B, r25
	; clear Compare Match Output, enable CTC mode
	ldi    r25, (0<<COM0A1)|(0<<COM0A0)|(0<<COM0B1)|(0<<COM0B0)|(1<<WGM01)|(0<<WGM00)
	out    TCCR0A, r25
	; Set compare value
	ldi    r25, 125 ; F_CPU=16Mhz, prescaler=1/256 --> trigger every 2ms
	out    OCR0A, r25
	out    OCR0B, r00 ; dont care
	; enable Compare Match A interrupt
	ldi    r25, (1<<OCIE0A)
	sts    TIMSK0, r25

	; Initialise m4164 driver
	; Physical connections:
	;
	;  N.C.  |  1  <---        --->  N.C. |  N/A
	;  Din   |  2  <--- Grey   --->  D12  |  Port B4
	; ~WE    |  3  <--- Black  --->  D10  |  Port B2
	; ~RAS   |  4  <--- Brown  --->  D9   |  Port B1
	;  A0    |  5  <--- Black  --->  D0   |  Port D0
	;  A2    |  6  <--- Grey   --->  D2   |  Port D2
	;  A1    |  7  <--- White  --->  D1   |  Port D1
	;  Vcc   |  8  <---        --->  N.C. |  N/A
	;  A7    |  9  <--- Orange --->  D7   |  Port D7
	;  A5    | 10  <--- Yellow --->  D5   |  Port D5
	;  A4    | 11  <--- Green  --->  D4   |  Port D4
	;  A3    | 12  <--- Blue   --->  D3   |  Port D3
	;  A6    | 13  <--- Purple --->  D6   |  Port D6
	;  Dout  | 14  <--- Red    --->  D8   |  Port B0
	; ~CAS   | 15  <--- White  --->  D11  |  Port B3
	;  Vss   | 16  <---        --->  N.C. |  N/A
	;
	ldi    zl, low(m4164_config)
	ldi    zh, high(m4164_config)
	ldi    r25, 128         $   std    z+m4164_config_row_count,    r25
	ldi    r25, 1<<PORTB2   $   std    z+m4164_config_WE_mask,      r25
	ldi    r25, 1<<PORTB4   $   std    z+m4164_config_Din_mask,     r25
	ldi    r25, 1<<PORTB0   $   std    z+m4164_config_Dout_mask,    r25
	ldi    r25, 1<<PORTB3   $   std    z+m4164_config_CAS_mask,     r25
	ldi    r25, 1<<PORTB1   $   std    z+m4164_config_RAS_mask,     r25

	ldi    zl, low(m4164_config)
	ldi    zh, high(m4164_config)
	call   m4164_init
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	sei

	jmp run_all_tests

	#define TESTS                                \
		((10, "All Zeroes", ramtest_write_zeroes)) \
		(( 8, "All Ones"  , ramtest_write_ones  )) \
	// TESTS

	#define OP(i, data, elem) STRING_CONSTANT_N( \
		BOOST_PP_CAT(                              \
			BOOST_PP_TUPLE_ELEM(2, elem),            \
			_desc                                    \
		),                                         \
		BOOST_PP_TUPLE_ELEM(0, elem),              \
		BOOST_PP_TUPLE_ELEM(1, elem))              \
	// OP
	BOOST_PP_SEQ_FOR_EACH(OP, _, TESTS)
	#undef OP

test_names:
	#define OP(i, data, elem)                    \
		high(BOOST_PP_CAT(                         \
			BOOST_PP_TUPLE_ELEM(2, elem),            \
			_desc                                    \
		)),                                        \
		low(BOOST_PP_CAT(                          \
			BOOST_PP_TUPLE_ELEM(2, elem),            \
			_desc                                    \
		)),                                        \
	// OP
	.db BOOST_PP_SEQ_FOR_EACH(OP, _, TESTS)
	#undef OP

test_funcs:
	#define OP(i, data, elem)                                           \
		.db                                                               \
			high(             BOOST_PP_TUPLE_ELEM(2, elem)        ),        \
			low (             BOOST_PP_TUPLE_ELEM(2, elem)        ),        \
			high(BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, elem), _desc)),        \
			low (BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, elem), _desc)),        \
		$\
	// OP
	BOOST_PP_SEQ_FOR_EACH(OP, _, TESTS)
	.db 0, 0 ; end of list
	#undef OP

#undef TESTS


run_all_tests:
	ldi    xl, low(FLASH_ADDR(test_funcs))
	ldi    xh, high(FLASH_ADDR(test_funcs))

run_next_test:
	mov    zl, xl
	mov    zh, xh

	; load test addr
	lpm    yh, z
	adiw   zl, 1
	lpm    yl, z
	adiw   zl, 1

	cp     r00, yl
	cpc    r00, yh
	brne   load_test_name
	jmp    run_tests_complete_passed

	; Determine and print test name
load_test_name:
	lpm    r25, z
	adiw   zl, 1
	lpm    r24, z
	adiw   zl, 1
	movw   xl, zl      ; save addr for next test
	push   r24         ; in-memory pointers are high, low
	push   r25
	ldi    r25, low(running_test)
	push   r25
	ldi    r25, high(running_test)
	push   r25
	call   _printf
	stack_free(4, r25)

	movw   zl, yl      ; set address of test

	icall              ; run test
	cpse   r25, r00    ; 0 = test passed, 1 = test failed
	rjmp   run_tests_complete_failed

	ldi    r25, low(test_passed)
	push   r25
	ldi    r25, high(test_passed)
	push   r25
	call   _printf
	stack_free(2, r25)

	jmp run_next_test

run_tests_complete_passed:
	ldi    r25, low(test_result_passed)
	push   r25
	ldi    r25, high(test_result_passed)
	push   r25
	call   _printf
	stack_free(2, r25)
	ldi    r25, low(crlf)
	push   r25
	ldi    r25, high(crlf)
	push   r25
	call   _printf
	stack_free(2, r25)
	debug_break(50) // slow blink = ok

run_tests_complete_failed:
	; Print 'failed'
	ldi    r25, low(test_failed)
	push   r25
	ldi    r25, high(test_failed)
	push   r25
	call   _printf
	stack_free(2, r25)
	; print 'bad chip'
	ldi    r25, low(test_result_failed)
	push   r25
	ldi    r25, high(test_result_failed)
	push   r25
	call   _printf
	stack_free(2, r25)
	; additional newline
	ldi    r25, low(crlf)
	push   r25
	ldi    r25, high(crlf)
	push   r25
	call   _printf
	stack_free(2, r25)
	debug_break(10) // fast blink = not ok



	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;; Ram test -- Write zeroes                                                 ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ramtest_write_zeroes:
	call   ramtest_write_zeroes_do_write
	rjmp   ramtest_write_zeroes_verify

ramtest_write_zeroes_do_write:
	save_registers(r16, zl, zh)
	ldi   zl, 0
	ldi   zh, 0
	ldi   r16, 0
__ramtest_write_zeroes_do_write_next_byte:
	call  m4164_dram_write_byte; auto increment z
	cpi   zl, 0
	brne  __ramtest_write_zeroes_do_write_next_byte
	cpi   zh, 0
	brne  __ramtest_write_zeroes_do_write_next_byte
	restore_registers(r16, zl, zh)
	ret

ramtest_write_zeroes_verify:
	save_registers(r16, zl, zh)
	ldi   zl, 0
	ldi   zh, 0
	ldi   r16, 0
__ramtest_write_zeroes_verify_next_byte:
	call  m4164_dram_read_byte; auto increment z
	or    r16, r25
	cpi   zl, 0
	brne  __ramtest_write_zeroes_verify_next_byte
	cpi   zh, 0
	brne  __ramtest_write_zeroes_verify_next_byte
	mov   r25, r16
	restore_registers(r16, zl, zh)
	ret

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;; Ram test -- Write ones                                                   ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ramtest_write_ones:
	call   ramtest_write_ones_do_write
	rjmp   ramtest_write_ones_verify

ramtest_write_ones_do_write:
	save_registers(r16, zl, zh)
	ldi   zl, 0
	ldi   zh, 0
	ldi   r16, 0xff
__ramtest_write_ones_do_write_next_byte:
	call  m4164_dram_write_byte; auto increment z
	cpi   zl, 0
	brne  __ramtest_write_ones_do_write_next_byte
	cpi   zh, 0
	brne  __ramtest_write_ones_do_write_next_byte
	restore_registers(r16, zl, zh)
	ret

ramtest_write_ones_verify:
	save_registers(r16, zl, zh)
	ldi   zl, 0
	ldi   zh, 0
	ldi   r16, 0xff
__ramtest_write_ones_verify_next_byte:
	call  m4164_dram_read_byte; auto increment z
	and   r16, r25
	cpi   zl, 0
	brne  __ramtest_write_ones_verify_next_byte
	cpi   zh, 0
	brne  __ramtest_write_ones_verify_next_byte
	mov   r25, r16
	eor   r25, r02 ; invert bits, should be all ones --> zeroes
	restore_registers(r16, zl, zh)
	ret

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


.dseg
	serial_rx_byte: .byte 1
	m4164_config: .byte struct_m4164_config_size

.cseg


loop:
	mov    r16, r01
	ldi    zl, low(serial_rx_byte)
	ldi    zh, high(serial_rx_byte)
	call  serial_read

	lds    r25, serial_rx_byte
	push   r25
	ldi    r25, low(read_byte)
	push   r25
	ldi    r25, high(read_byte)
	push   r25
	call   _printf
	stack_free(3, r25)
	rjmp  loop


error_trap:
	break
	debug_break(4)
	rjmp error_trap



.set string_constants_reserved_space = 512
.set string_constants_org = (FLASHEND - string_constants_reserved_space + 1)/2
.if string_constants_org < (RAMEND+1)/2
	.error "String constants must be allocated at a flash address > RAMEND"
.endif
.org string_constants_org

STRING_CONSTANT_N(read_byte, 19, "read byte: '%hhx'", STRING_CONSTANT_CRLF);
STRING_CONSTANT_N(running_test, 20, "Running test '%s'...");
STRING_CONSTANT_N(test_passed, 9, " passed", STRING_CONSTANT_CRLF);
STRING_CONSTANT_N(test_failed, 9, " FAILED", STRING_CONSTANT_CRLF);
STRING_CONSTANT_N(test_result_passed, 54, "All tests completed, this memory chip seems fine :-)", STRING_CONSTANT_CRLF);
STRING_CONSTANT_N(test_result_failed, 58, "The last test failed, this memory chip may be broken :-(", STRING_CONSTANT_CRLF);
STRING_CONSTANT_N(crlf, 2, STRING_CONSTANT_CRLF);

string_constants_eof:
.if FLASH_ADDR(string_constants_eof) - 1 > FLASHEND
	.error "Not enough reserved space to store all string constants (ran out of flash!)"
.endif
