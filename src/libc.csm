/******************************************************************************

   The familiar C set of functions. Sorta.

   Note:
   The IO functions assume that any pointer with a value <= RAMEND points
   into RAM, while any RAMEND < pointer <= FLASHEND is considered to be a
   pointer into ROM. A pointer value > FLASHEND is considered invalid. I/O
   space is considered RAM. This implies that there is a small region of
   ROM which cannot be used for ROM pointers (0..RAMEND).

   Definitions
   -------------------------------------------------------------------------
    * sizeof(int) == 16
    * byte order of e.g. integers in memory is msb first.
      E.g. 0x1234 is stored as ... 0x12 0x34 ... and 0x12345678 is stored
      as ... 0x12 0x34 0x56 0x78 ...
    * arguments are passed on the stack in reverse order (i.e. first argument
      should be pushed last).

 ******************************************************************************/
#pragma once
#include "abi.csm"
#include "utility_macros.csm"
#include <boost/preprocessor/control/iif.hpp>
#include <boost/preprocessor/seq/cat.hpp>
#include <boost/preprocessor/seq/cat.hpp>


////////////////////////////////////////////////////////////////////////////////

#define libc_config(                                                             \
	write_rom,                                                                     \
	write_ram,                                                                     \
	write_wait_complete                                                            \
)                                                                                \
	.define __libc_config_write_rom             write_rom                         $\
	.define __libc_config_write_ram             write_ram                         $\
	.define __libc_config_write_wait_complete   write_wait_complete               $\
// ssd1306_config





////////////////////////////////////////////////////////////////////////////////
#define SAVE_Z_REG_AND_LOAD_x SAVE_Z_REG_AND_LOAD(x)
#define SAVE_Z_REG_AND_LOAD_y SAVE_Z_REG_AND_LOAD(y)
#define SAVE_Z_REG_AND_LOAD_z
#define SAVE_Z_REG_AND_LOAD(x)                                                   \
	push  zl                                                                      $\
	push  zh                                                                      $\
	mov   zl, x ## l                                                              $\
	mov   zh, x ## h                                                              $\
// SAVE_Z_REG_AND_LOAD

////////////////////////////////////////////////////////////////////////////////
#define RESTORE_Z_REG_x RESTORE_Z_REG(x)
#define RESTORE_Z_REG_y RESTORE_Z_REG(y)
#define RESTORE_Z_REG_z
#define RESTORE_Z_REG(x)                                                         \
	pop   zh                                                                      $\
	pop   zl                                                                      $\
// RESTORE_Z_REG

////////////////////////////////////////////////////////////////////////////////
; in:  z
; out: r25
DEF_LABELED(_is_ram_addr,                                                       $\
	cpi   zl, low(RAMEND+1)                                                       $\
	ldi   r25, high(RAMEND+1)                                                     $\
	cpc   zh, r25           ; if(z <= RAMEND) C=1 else C=0                        $\
	; if z < RAMEND it is either RAM or IO,                                       $\
	; but we consider both as RAM                                                 $\
	clr   r25                                                                     $\
	adc   r25, rC0                                                                $\
	ret                                                                           $\
)
#define is_ram_addr(x)                                                           \
	SAVE_Z_REG_AND_LOAD_ ## x                                                      \
	call _is_ram_addr                                                             $\
	RESTORE_Z_REG_ ## x                                                            \
// is_ram_addr()


////////////////////////////////////////////////////////////////////////////////
; in:  z
;      SP
; out: r25
DEF_LABELED(_is_rom_addr,                                                       $\
	cpi   zl, low(FLASHEND+1)                                                     $\
	ldi   r25, high(FLASHEND+1)                                                   $\
	cpc   zh, r25                                                                 $\
	; if z < FLASHEND it is either ROM or RAM,                                    $\
	; but if z > FLASHEND it is just invalid (so we say it is not rom)            $\
	brsh  __is_rom_addr     ; if(z<=FLASHEND) C=1 else C=0                        $\
	                                                                              $\
	; See if it is RAM rather than ROM                                            $\
	; if both RAM and ROM it is RAM (and not rom)                                 $\
	ldi   r25, low(RAMEND)                                                        $\
	cp    r25, zl                                                                 $\
	ldi   r25, high(RAMEND)                                                       $\
	cpc   r25, zh           ; if(RAMEND < z) C=1 else C=0                         $\
__is_rom_addr:                                                                  $\
	clr   r25                                                                     $\
	adc   r25, rC0                                                                $\
	ret                                                                           $\
)
#define is_rom_addr(x)                                                           \
	SAVE_Z_REG_AND_LOAD_ ## x                                                      \
	call _is_rom_addr                                                             $\
	RESTORE_Z_REG_ ## x                                                            \
// is_ram_addr()

////////////////////////////////////////////////////////////////////////////////
;   z: buffer
; r16: buffer length           ; XXX: switch rom/ram
DEF_LABELED(_puts,                                                              $\
	call  __libc_config_write_wait_complete                                       $\
	call  __libc_config_write_rom                                                 $\
	ret ; XXX: puts should add a newline                                          $\
)
#define puts(x)                                                                 $\
	save_registers(zl, zh, r16)                                                   $\
	ldi   r16, STRING_CONSTANT_LENGTH(x)                                          $\
	ldi   zl, low(x)                                                              $\
	ldi   zh, high(x)                                                             $\
	call  _puts                                                                   $\
	restore_registers(zl, zh, r16)                                                $\
// puts()

////////////////////////////////////////////////////////////////////////////////
; z: pointer
; returns length of string in r25
DEF_LABELED(_strlen,                                                            $\
	save_registers(r23)                                                           $\
	rcall  _is_ram_addr                                                           $\
	mov    r23, r25                                                               $\
	clr    r25                                                                    $\
__strlen_next_char:                                                             $\
	ld     r24, z                                                                 $\
	cpse   r23, rC1                                                               $\
	lpm    r24, z                                                                 $\
	adiw   zl, 1                                                                  $\
	add    r25, rC1                                                               $\
	cpse   r24, rC0                                                               $\
	rjmp   __strlen_next_char                                                     $\
	sub    zl, r25                                                                $\
	sbc    zh, rC0                                                                $\
	sub    r25, rC1                                                               $\
	restore_registers(r23)                                                        $\
	ret                                                                           $\
)


////////////////////////////////////////////////////////////////////////////////
DEF_LABELED(__printf_variables,                                                 $\
	.dseg                                                                         $\
	; Note:                                                                       $\
	; The work area is allocated separately, so that we do not have to wait for   $\
	; serial TX end before returning from printf() when the last thing to print   $\
	; was a format specifier.                                                     $\
__printf_arg_ptr:   .byte 2                                                     $\
__printf_work_area: .byte 10 ; 4-byte unsigned printed as decimal               $\
__printf_work_area_end:                                                         $\
	.set __printf_work_area_size = __printf_work_area_end - __printf_work_area    $\
	.cseg
)

; z: pointer to format string
; stack: arguments, pushed in reverse order of appearance. I.e. first argument
;        in format string is pushed last.
;
; ret: r25 = num chars written, or -1 on error
DEF_LABELED(_printf,                                                            $\
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;$\
	.set __printf_conversion_specifier_bit  = 7                                   $\
	.set __printf_escape_seq_bit            = 6                                   $\
	                                                                              $\
	.set __printf_conversion_specifier_mask =                                      \
	     1 << __printf_conversion_specifier_bit                                   $\
	.set __printf_escape_seq_mask           =                                      \
	     1 << __printf_escape_seq_bit                                             $\
	                                                                              $\
	.set __printf_argument_length_mask      = 0x07                                $\
	                                                                              $\
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;$\
	; set the current argument (before mangling sp, not using stack)              $\
	;                                                                             $\
	; When called, SP points to the first free stack byte, so we need to add 1    $\
	; to get at the first byte of the return address. The return address is       $\
	; pushed onto the stack lsb first (i.e. push low(PC); push high(PC), so in    $\
	; memory order the most significant byte comes first). The return address     $\
	; points at the instruction following the call. Additionally the address      $\
	; that is stored is the _word_ address, so to get the byte address it needs   $\
	; to be multiplied by two (e.g. if it needs to match up with the              $\
	; disassembly).                                                               $\
	; We also need to skip the return address to get at the first argument, for   $\
	; a total of 3 bytes adjustment.                                              $\
	ldi    r24,  3 ; adjust sp                                                    $\
	in     r25, SPL                                                               $\
	add    r25, r24                                                               $\
	sts    __printf_arg_ptr+1, r25                                                $\
	in     r25, SPH                                                               $\
	adc    r25, rC0                                                               $\
	sts    __printf_arg_ptr+0, r25                                                $\
	                                                                              $\
	save_registers(                                                                \
		r08, r09,                                                                    \
		r16, r19,                                                                    \
		r20, r21, r22, r23,                                                          \
		xl, xh, yl, yh, zl, zh                                                       \
	)                                                                             $\
	                                                                              $\
	; fetch the format string pointer into z, update arg ptr                      $\
	lds    xl, __printf_arg_ptr+1                                                 $\
	lds    xh, __printf_arg_ptr+0                                                 $\
	ld     zh, x+                                                                 $\
	ld     zl, x+                                                                 $\
	sts    __printf_arg_ptr+1, xl                                                 $\
	sts    __printf_arg_ptr+0, xh                                                 $\
	                                                                              $\
	is_ram_addr(z)                                                                $\
	mov    r08, r25      ; r08 will decide if we use (0) lpm or (1) plain ld      $\
	ldi    r25, '%'      ;                                                        $\
	mov    r09, r25      ; r09 is the conversion specifier introductory character $\
	clr    r16           ; r16 will be the length of the unprinted string         $\
	ldi    r22, 2        ; r22 will be flags; lower 3 bits indicate length        $\
	clr    r23           ; r23 will be 'in conversion specifier' + type?          $\
	movw   xl, zl        ; x will always point at the first unprinted byte        $\
	                                                                              $\
	rjmp   __printf_start                                                         $\
	                                                                              $\
)

DEF_LABELED(; main loop,                                                        $\
	; Either not a valid conversion specifier, or not implemented                 $\
	; switch back to regular printing                                             $\
__printf_conversion_specifier_error:                                            $\
	/*puts(excl)*/                                                                $\
	andi    r23, BITINV(__printf_conversion_specifier_mask)                       $\
	                                                                              $\
	; We get here if we've just read a char, we're not parsing a conversion       $\
	; specifier, and the char we read is not '%'                                  $\
__printf_next_char:                                                             $\
	adiw   zl, 1                                                                  $\
	inc    r16 ; one more char for the output buffer                              $\
	                                                                              $\
__printf_start:                                                                 $\
	ld     r25, z                                                                 $\
	cpse   r08, rC1                                                               $\
	lpm    r25, z                                                                 $\
	                                                                              $\
	; see if it is eol                                                            $\
	tst    r25                                                                    $\
	breq   __printf_done                                                          $\
	                                                                              $\
	sbrc   r23, __printf_conversion_specifier_bit                                 $\
	rjmp   __printf_conversion_specifier_seq                                      $\
	                                                                              $\
	; see if it is the conversion specifier introductory character                $\
	cpse   r25, r09                                                               $\
	rjmp   __printf_next_char                                                     $\
	                                                                              $\
	; it is the conversion specifier introductory character,                      $\
	; output current buffer and switch to conversion specifier mode               $\
	cpse   r16, rC0                                                               $\
	rcall  __printf_write                                                         $\
	ori    r23, __printf_conversion_specifier_mask                                $\
	movw   xl, zl   ; remember start position (xl points at '%')                  $\
	mov    r16, rC0 ; updated in __printf_next_char                               $\
	rjmp   __printf_next_char                                                     $\
	                                                                              $\
	; currently _in_ a conversion specifier                                       $\
__printf_conversion_specifier_seq:                                              $\
	                                                                              $\
	; check for -/+/ /#/0                                                         $\
	                                                                              $\
	                                                                              $\
	; check for field width (int or *)                                            $\
	                                                                              $\
	                                                                              $\
	; check for precision (. followed by int or *)                                $\
	                                                                              $\
)

DEF_LABELED(; length modifiers,                                                 $\
	; check for length modifier (h, l)                                            $\
__printf_length_modifier_h:                                                     $\
	ldi    r24, 'h'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_length_modifier_l                                             $\
	mov    r25, r22                                                               $\
	andi   r25, __printf_argument_length_mask                                     $\
	cp     r25, rC0                                                               $\
	breq   __printf_conversion_specifier_error                                    $\
	dec    r25                                                                    $\
	andi   r22, BITINV(__printf_argument_length_mask)                             $\
	or     r22, r25                                                               $\
	rjmp   __printf_next_char                                                     $\
	                                                                              $\
__printf_length_modifier_l:                                                     $\
	ldi    r24, 'l'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_conversion_format_specifiers                                  $\
	mov    r25, r22                                                               $\
	andi   r25, __printf_argument_length_mask                                     $\
	ldi    r24, 0x04                                                              $\
	cp     r25, r24                                                               $\
	breq   __printf_conversion_specifier_error                                    $\
	inc    r25                                                                    $\
	andi   r22, BITINV(__printf_argument_length_mask)                             $\
	or     r22, r25                                                               $\
	rjmp   __printf_next_char                                                     $\
)

DEF_LABELED(__printf_conversion_format_specifiers,                              $\
	; see if it is any of the conversion format specifiers                        $\
__printf_conversion_format_specifier_s:                                         $\
	ldi    r24, 's'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_conversion_format_specifier_d                                 $\
	rjmp   __printf_s                                                             $\
	                                                                              $\
__printf_conversion_format_specifier_d:                                         $\
	ldi    yl, low(__printf_d)                                                    $\
	ldi    yh, high(__printf_d)                                                   $\
	ldi    r24, 'd'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_conversion_format_specifier_x                                 $\
	rjmp   __printf_do_format                                                     $\
	                                                                              $\
__printf_conversion_format_specifier_x:                                         $\
	ldi    yl, low(__printf_x)                                                    $\
	ldi    yh, high(__printf_x)                                                   $\
	ldi    r24, 'x'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_conversion_format_specifier_xx                                $\
	rjmp   __printf_do_format                                                     $\
__printf_conversion_format_specifier_xx:                                        $\
	ldi    r24, 'X'                                                               $\
	cpse   r25, r24                                                               $\
	rjmp   __printf_conversion_format_specifier_no_match                          $\
	rjmp   __printf_do_format                                                     $\
	                                                                              $\
	; Nothing valid matched in conversion format specifier                        $\
__printf_conversion_format_specifier_no_match:                                  $\
	rjmp   __printf_conversion_specifier_error                                    $\
)

DEF_LABELED(; exit points,                                                      $\
__printf_ret_error:                                                             $\
	mov    r25, rC2                                                               $\
	                                                                              $\
__printf_done:                                                                  $\
	cpse   r16, rC0                                                               $\
	rcall  __printf_write ; print any remaining chars                             $\
	                                                                              $\
	; when printing from RAM, the user buffer may not be used after exiting so    $\
	; we need to wait with exiting until we are done using it.                    $\
	cpse   r08, rC0                                                               $\
	rcall  __libc_config_write_wait_complete                                      $\
	                                                                              $\
	/*puts(hash)*/                                                                $\
	restore_registers(                                                            \
		r08, r09,                                                                   \
		r16, r19,                                                                   \
		r20, r21, r22, r23,                                                         \
		xl, xh, yl, yh, zl, zh                                                      \
	)                                                                             $\
	ret                                                                           $\
)

; prints the currently accumulated buffer (in xl)
; len should be in r16 already
; saves z
; clobbers y
DEF_LABELED(__printf_write,                                                     $\
	/*puts(abrackl)*/                                                             $\
	movw   yl, zl   ; save current position                                       $\
	movw   zl, xl   ; output buffer start, r16 is already set to len              $\
	call   __libc_config_write_wait_complete                                      $\
	cpse   r08, rC1                                                               $\
	call   __libc_config_write_rom                                                $\
	cpse   r08, rC0                                                               $\
	call   __libc_config_write_ram                                                $\
	movw   zl, yl   ; restore current position                                    $\
	/*puts(abrackr)*/                                                             $\
	ret                                                                           $\
)

; xl points at '%', zl points at 's'
; (precision and length modifier is not yet supported)
DEF_LABELED(__printf_s,                                                         $\
	; save position                                                               $\
	movw   xl, zl                                                                 $\
	                                                                              $\
	; determine if string is in ROM or RAM                                        $\
	lds    yl, __printf_arg_ptr+1                                                 $\
	lds    yh, __printf_arg_ptr+0                                                 $\
	ld     zh, y+                                                                 $\
	ld     zl, y+                                                                 $\
	sts    __printf_arg_ptr+1, yl ; update arg ptr                                $\
	sts    __printf_arg_ptr+0, yh ; next argument                                 $\
	                                                                              $\
	rcall  _strlen                                                                $\
	mov    r16, r25                                                               $\
	                                                                              $\
	rcall  _is_ram_addr                                                           $\
	mov    r21, r25                                                               $\
	call   __libc_config_write_wait_complete                                      $\
	cpse   r21, rC1                                                               $\
	call   __libc_config_write_rom                                                $\
	cpse   r21, rC0                                                               $\
	call   __libc_config_write_ram                                                $\
	                                                                              $\
	; switch back to normal printing                                              $\
	andi   r23, BITINV(__printf_conversion_specifier_mask)                        $\
	movw   zl, xl                                                                 $\
	ldi    r22, 2         ; Reset format flags for next round.                    $\
	mov    r16, rC2       ; Start fresh. There is an inc in __printf_next_char    $\
	adiw   xl, 1          ; which will overflow r16 to 0 and inc z, but for x     $\
	rjmp   __printf_next_char ; we have to do it here.                            $\
)


DEF_LABELED(__printf_do_format,                                                 $\
	; save pointer to format string, ready format routine pointer (swap x and z)  $\
	; Note: at this point z points *at* 'x'                                       $\
	;                     y points *at* '%'                                       $\
	;                     x points *at* function                                  $\
	movw  xl, zl                                                                  $\
	                                                                              $\
	; determine argument length (bytes)                                           $\
	; it seems that the calculation is probably faster/easier than a lookup table $\
	; because of the cumbersome offset calculation                                $\
	mov    r25, r22                                                               $\
	andi   r25, __printf_argument_length_mask                                     $\
	ldi    zl, low(2*__printf_arglen_int_lookup)                                  $\
	ldi    zh, high(2*__printf_arglen_int_lookup)                                 $\
	add    zl, r25                                                                $\
	adc    zh, rC0                                                                $\
	lpm    r23, z   ; r23 is the length of the argument                           $\
	                                                                              $\
	movw   zl, yl   ; prepare for icall to real printing routine                  $\
	lds    yl, __printf_arg_ptr+1                                                 $\
	lds    yh, __printf_arg_ptr+0                                                 $\
	                                                                              $\
	; We are about to (re)use the (shared) __printf_work_area                     $\
	call   __libc_config_write_wait_complete                                      $\
	                                                                              $\
	icall  ; do actual formatting                                                 $\
	                                                                              $\
	; update arg ptr                                                              $\
	sts    __printf_arg_ptr+1, yl                                                 $\
	sts    __printf_arg_ptr+0, yh ; next argument                                 $\
	                                                                              $\
	; find start of output (skip leading 0s)                                      $\
	movw   zl, xl         ; restore z                                             $\
	ldi    xl, low(__printf_work_area)                                            $\
	ldi    xh, high(__printf_work_area) ; __printf_write needs ptr in x           $\
	ldi    r24, '0'                                                               $\
__printf_do_format_skip_leading_zero:                                           $\
	ld     r25, x+                                                                $\
	sub    r16, rC1                                                               $\
	cp     r25, r24                                                               $\
	; ensure we write at least one character, since otherwise we cannot print     $\
	; 0 itself.                                                                   $\
	cpse   r16, rC0                                                               $\
	breq   __printf_do_format_skip_leading_zero                                   $\
	sbiw   xl, 1                                                                  $\
	add    r16, rC1                                                               $\
	                                                                              $\
	; write buffer (r16 is set correctly above)                                   $\
	; at this point xl = current pos, z is preserved,                             $\
	; and z needs to be restored before exit                                      $\
	mov    r22, r08       ; r22 is not needed anymore (for this format specifier) $\
	mov    r08, rC1       ; always write from ram (__printf_work_area)            $\
	; r16 must always > 0 here                                                    $\
	rcall  __printf_write                                                         $\
	mov    r08, r22                                                               $\
	                                                                              $\
	; switch back to normal printing                                              $\
	andi   r23, BITINV(__printf_conversion_specifier_mask)                        $\
	; zl already points at the current position                                   $\
	; but xl points at the work area rather than the start of the current seq.    $\
	movw   xl, zl                                                                 $\
	ldi    r22, 2         ; Reset format flags for next round.                    $\
	mov    r16, rC2       ; Start fresh. There is an inc in __printf_next_char    $\
	adiw   xl, 1          ; which will overflow r16 to 0 and inc z, but for x     $\
	rjmp   __printf_next_char ; we have to do it here.                            $\
)


; x   = current char ptr
; y   = arg ptr
; z   = work area ptr
; r16 = free (format specifier length (+/1))
; r25 = free
; r24 = free
; r23 = length of arg
; r22 = free
; r21 = free (unused)
; r20 = free (unused)
DEF_LABELED(__printf_d,                                                         $\
	mov    r16, r23 ; arg len                                                     $\
	call   bcd2bin_bytes                                                          $\
	mov    r23, r25 ; change arg len to match with bcd encoded arg                $\
	                                                                              $\
	movw   zl, xl   ; save current char ptr                                       $\
	movw   xl, yl   ; xl points to arg                                            $\
	ldi    yl, low(__printf_work_area_end)                                        $\
	ldi    yh, high(__printf_work_area_end)                                       $\
	add    yl, r24  ; yl points to output buf                                     $\
	call   bin2bcd                                                                $\
	                                                                              $\
	; evil hack, jump to __printf_x                                               $\
	; xl should point to current char                                             $\
	; yl already points to (our) arg                                              $\
	; zl should point to work area                                                $\
	add    xl, r16                                                                $\
	adc    xh, rC0  ; we will use up this many bytes of the input                 $\
	push   xl                                                                     $\
	push   xh       ; save (updated) original arg ptr                             $\
	movw   xl, zl   ; x points to current char                                    $\
	ldi    zl, low(__printf_work_area) ; z points to output buf                   $\
	ldi    zh, high(__printf_work_area)                                           $\
	call   __printf_x_d_insertion_point                                           $\
	                                                                              $\
	; restore                                                                     $\
	pop    yh       ; restore arg ptr                                             $\
	pop    yl                                                                     $\
	ret                                                                           $\
)

DEF_LABELED(__printf_x,                                                         $\
	; determine capitals/non-capitals                                             $\
	movw   zl, xl                                                                 $\
	ld     r22, z                                                                 $\
	cpse   r08, rC1                                                               $\
	lpm    r22, z                                                                 $\
	subi   r22, 0x0a + '0' + 'x' - 'a'                                            $\
	                                                                              $\
	__printf_x_d_insertion_point:                                                 $\
	ldi    zl, low(__printf_work_area)                                            $\
	ldi    zh, high(__printf_work_area)                                           $\
	mov    r16, r23                                                               $\
	lsl    r16      ; 2 chars/byte                                                $\
	                                                                              $\
__printf_x_next_byte:                                                           $\
	ld     r25, y   ; separate register makes __printf_d work,                    $\
	ld     r24, y   ; uses overlapping src/dst.                                   $\
	                                                                              $\
	; high nibble                                                                 $\
	lsr    (r25, 4)                                                               $\
	andi   r25, 0x0f                                                              $\
	cpi    r25, 0x0a                                                              $\
	brlo   __printf_x_next_byte_high                                              $\
	add    r25, r22                                                               $\
__printf_x_next_byte_high:                                                      $\
	subi   r25, -'0'                                                              $\
	st     z, r25                                                                 $\
	adiw   zl, 1                                                                  $\
	                                                                              $\
	; low nibble                                                                  $\
	andi   r24, 0x0f                                                              $\
	cpi    r24, 0x0a                                                              $\
	brlo   __printf_x_next_byte_low                                               $\
	add    r24, r22                                                               $\
__printf_x_next_byte_low:                                                       $\
	subi   r24, -'0'                                                              $\
	st     z, r24                                                                 $\
	adiw   zl, 1                                                                  $\
	                                                                              $\
	; done?                                                                       $\
	adiw   yl, 1                                                                  $\
	dec    r23                                                                    $\
	brne   __printf_x_next_byte                                                   $\
	                                                                              $\
	ret                                                                           $\
)

DEF_LABELED(__printf_constants,                                                 $\
	.cseg                                                                         $\
	                          /*  %hh, %h,  %, %l, %ll */                         $\
__printf_arglen_int_lookup: .db   1,  2,  2,  4,   8,  0                        $\
)
